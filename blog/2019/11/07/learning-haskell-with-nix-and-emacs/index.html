<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>Learning Haskell with nix and Emacs - org-page</title>
    <meta charset="utf-8" />
    <meta name="author" content="shanexu" />
    <meta name="description" content="Learning Haskell with nix and Emacs" />
    <meta name="keywords" content="haskell, nix, emacs" />
    <link rel="stylesheet" href="/media/css/main.css" type="text/css">
    <link rel="stylesheet" href="/media/css/prettify.css" type="text/css">
  </head>
  <body class="container">
    <div>
      <header class="masthead">
        <h1 class="masthead-title"><a href="/">org-page</a></h1>
        <p>static site generator</p>
        <ul>
          <li><a href="/blog/">Blog</a></li>
          <li><a href="/tags/">Tags</a></li>
          <li><a href="/about/">About</a></li>
          <li><a href="https://github.com/kelvinh/org-page">GitHub</a></li>
          <li><a href="/rss.xml">RSS</a></li>
        </ul>
        <form method="get" id="searchform" action="//www.google.com/search">
          <input type="text" class="field" name="q" id="s" placeholder="Search">
          <input type="hidden" name="as_sitesearch" value="xusheng.org">
        </form>
      </header>
    </div>

<div>
<div class="post">
<h1>Learning Haskell with nix and Emacs</h1>

<div id="outline-container-org568af55" class="outline-2">
<h2 id="org568af55">前言</h2>
<div class="outline-text-2" id="text-org568af55">
<p>
<a href="https://github.com/haskell-servant/servant">haskell-servant</a> 和 <a href="https://github.com/dmjio/miso">miso</a> 等haskell开源项目竟然都是用nix管理依赖的。时隔多年nix竟然被赋予了这样的魔法，不仅让我大跌眼镜。在 <a href="https://github.com/Gabriel439/haskell-nix">Nix and Haskell in production</a> 一文中指出，nix对标的其实是stack，他和stack一样有独立的haskell包缓存，用以达成reproducible的构建。nix胜过stack的唯一个地方，就是他不仅能解决haskell包依赖，还能解决其他任何依赖，甚至可以为你打造一个独立的开发环境。本文就是介绍如何在 <code>macos catalina</code> 上用nix打造一个haskell开发环境。
</p>
</div>
</div>

<div id="outline-container-org9724a0b" class="outline-2">
<h2 id="org9724a0b">安装nix和其他工具</h2>
<div class="outline-text-2" id="text-org9724a0b">
<p>
本来这一个步骤应该是非常简单的。但是在最新版的macos catalina上并不那么容易了。nix需要在根目录上创建文件夹 <code>/nix</code> ，在系统默认开启 <code>SIP</code> 的情况下，根目录是以只读度方式挂载的，所以无法创建。首先需要关闭SIP，创建目录，重新启用SIP，由于启用后根目录仍然只读，还需要创建分区，将分区挂载到 <code>/nix</code> 。
</p>

<p>
关闭SIP方法可参考文档： <a href="https://support.studionetworksolutions.com/hc/en-us/articles/115003839246-How-to-disable-Systems-Integrity-Protection-SIP-in-macOS">How to disable Systems Integrity Protection (SIP) in macOS</a> 
</p>

<div class="org-src-container">
<pre class="src src-text">  PASSPHRASE=$(openssl rand -base64 32)
  echo "Creating encrypted APFS volume with passphrase: $PASSPHRASE" &gt;&amp;2
  sudo diskutil apfs addVolume disk1 'Case-sensitive APFS' Nix -mountpoint /nix -passphrase "$PASSPHRASE"
  UUID=$(diskutil info -plist /nix | plutil -extract VolumeUUID xml1 - -o - | plutil -p - | sed -e 's/"//g')
  echo $UUID
  security add-generic-password -l Nix -a "$UUID" -s "$UUID" -D "Encrypted Volume Password" -w "$PASSPHRASE" \\n -T "/System/Library/CoreServices/APFSUserAgent" -T "/System/Library/CoreServices/CSUserAgent"
  sudo diskutil enableOwnership /nix
  echo 'LABEL=Nix /nix apfs rw' | sudo tee -a /etc/fstab &gt;/dev/null
</pre>
</div>

<p>
挂载完后， <code>df -h</code> 命令查看当前磁盘状态如下。
</p>


<div class="org-src-container">
<pre class="src src-text">  Filesystem      Size   Used  Avail Capacity iused      ifree %iused  Mounted on
  /dev/disk1s5   466Gi   10Gi  211Gi     5%  483643 4881969237    0%   /
  devfs          199Ki  199Ki    0Bi   100%     690          0  100%   /dev
  /dev/disk1s1   466Gi  232Gi  211Gi    53% 3527520 4878925360    0%   /System/Volumes/Data
  /dev/disk1s4   466Gi  2.0Gi  211Gi     1%       2 4882452878    0%   /private/var/vm
  map auto_home    0Bi    0Bi    0Bi   100%       0          0  100%   /System/Volumes/Data/home
  /dev/disk1s6   466Gi  9.8Gi  211Gi     5%  256476 4882196404    0%   /nix  
</pre>
</div>

<p>
之后就可以按照官方文档所述，安装 <code>nix</code> 了。
</p>

<div class="org-src-container">
<pre class="src src-shell-script">  curl https://nixos.org/nix/install | sh  
</pre>
</div>

<p>
关于nix和macos catalina和sip的问题可以看下，nix的一个issues： <a href="https://github.com/NixOS/nix/issues/2925">/nix will not be writable on macOS Catalina #2925</a>
</p>

<p>
nix安装完之后就可以安装开发工具了。
</p>

<div class="org-src-container">
<pre class="src src-shell-script">  nix-env --install cabal2nix stack cabal-install
</pre>
</div>
</div>
</div>

<div id="outline-container-orge32ae06" class="outline-2">
<h2 id="orge32ae06">使用stack初始化工程</h2>
<div class="outline-text-2" id="text-orge32ae06">
<div class="org-src-container">
<pre class="src src-shell-script">  stack new helloworld new-template
</pre>
</div>

<p>
工程结构如下
</p>

<div class="org-src-container">
<pre class="src src-text">  .
  ├── ChangeLog.md
  ├── LICENSE
  ├── README.md
  ├── Setup.hs
  ├── app
  │   └── Main.hs
  ├── helloworld.cabal
  ├── package.yaml
  ├── src
  │   └── Lib.hs
  ├── stack.yaml
  └── test
      └── Spec.hs
</pre>
</div>

<p>
修改 .gitignore
</p>

<div class="org-src-container">
<pre class="src src-text">  .stack-work/
  *~
  /result
  *.hi
  *.o
  dist-newstyle/
</pre>
</div>

<p>
初始化git仓库
</p>

<div class="org-src-container">
<pre class="src src-shell-script">  git init
</pre>
</div>


<p>
此时可以用 <code>stack run</code> 编译并运行。
</p>

<div class="org-src-container">
<pre class="src src-text">  Building all executables for `helloworld' once. After a successful build of all of them, only specified executables will be rebuilt.
  helloworld&gt; configure (lib + exe)
  Configuring helloworld-0.1.0.0...
  helloworld&gt; build (lib + exe)
  Preprocessing library for helloworld-0.1.0.0..
  Building library for helloworld-0.1.0.0..
  [1 of 2] Compiling Lib
  [2 of 2] Compiling Paths_helloworld
  Preprocessing executable 'helloworld-exe' for helloworld-0.1.0.0..
  Building executable 'helloworld-exe' for helloworld-0.1.0.0..
  [1 of 2] Compiling Main
  [2 of 2] Compiling Paths_helloworld
  Linking .stack-work/dist/x86_64-osx/Cabal-2.4.0.1/build/helloworld-exe/helloworld-exe ...
  helloworld&gt; copy/register
  Installing library in /Users/shane/src/github.com/shanexu/helloworld/.stack-work/install/x86_64-osx/12a66049aaca4a8b492b9641af325fbaf91178a6bf5ad4ae4f7714e26944d4c7/8.6.5/lib/x86_64-osx
  -ghc-8.6.5/helloworld-0.1.0.0-5AFk17aNCLW4CrcpWxCXgp
  Installing executable helloworld-exe in /Users/shane/src/github.com/shanexu/helloworld/.stack-work/install/x86_64-osx/12a66049aaca4a8b492b9641af325fbaf91178a6bf5ad4ae4f7714e26944d4c7/8.
  6.5/bin
  Registering library for helloworld-0.1.0.0..
  someFunc  
</pre>
</div>
</div>
</div>

<div id="outline-container-org4f002e7" class="outline-2">
<h2 id="org4f002e7">编写第一个nix表达式</h2>
<div class="outline-text-2" id="text-org4f002e7">
<p>
说是编写，其实就是中 cabal2nix 生成。
</p>

<div class="org-src-container">
<pre class="src src-shell-script">  cabal2nix . &gt; helloworld.nix
</pre>
</div>

<p>
helloworld.nix 的内容如下：
</p>

<div class="org-src-container">
<pre class="src src-nix"><span class="linenr"> 1: </span>  { mkDerivation, base, hpack, stdenv }:
<span class="linenr"> 2: </span>  mkDerivation {
<span class="linenr"> 3: </span>    pname = "helloworld";
<span class="linenr"> 4: </span>    version = "0.1.0.0";
<span class="linenr"> 5: </span>    src = ./.;
<span class="linenr"> 6: </span>    isLibrary = true;
<span class="linenr"> 7: </span>    isExecutable = true;
<span class="linenr"> 8: </span>    libraryHaskellDepends = [ base ];
<span class="linenr"> 9: </span>    libraryToolDepends = [ hpack ];
<span class="linenr">10: </span>    executableHaskellDepends = [ base ];
<span class="linenr">11: </span>    testHaskellDepends = [ base ];
<span class="linenr">12: </span>    prePatch = "hpack";
<span class="linenr">13: </span>    homepage = "https://github.com/shanexu/helloworld#readme";
<span class="linenr">14: </span>    license = stdenv.lib.licenses.bsd3;
<span class="linenr">15: </span>  }  
</pre>
</div>

<p>
编写 <code>default.nix</code> 
</p>

<div class="org-src-container">
<pre class="src src-nix"><span class="linenr">1: </span>  let
<span class="linenr">2: </span>    pkgs = import &lt;nixpkgs&gt; { };
<span class="linenr">3: </span>  in
<span class="linenr">4: </span>    pkgs.haskellPackages.callPackage ./helloworld.nix { }
</pre>
</div>

<p>
使用nix build
</p>
<div class="org-src-container">
<pre class="src src-shell-script">  nix-build
</pre>
</div>

<p>
默认 <code>nix-build</code> 会在当前目录下找 <code>default.nix</code> 文件，并使用这个文件执行build任务。
</p>

<div class="org-src-container">
<pre class="src src-text">  these derivations will be built:
    /nix/store/lq4nibqgmvrb8j3yl460jqpc7ysbi417-helloworld-0.1.0.0.drv
  building '/nix/store/lq4nibqgmvrb8j3yl460jqpc7ysbi417-helloworld-0.1.0.0.drv'...
  setupCompilerEnvironmentPhase
  Build with /nix/store/kdmykixl5nafbygjp5i8a6b4iclmfm1l-ghc-8.6.5.
  unpacking sources
  unpacking source archive /nix/store/dfa15ibdmddj3pvq5zr1g01df2zr186d-helloworld
  source root is helloworld
  patching sources
  helloworld.cabal is up-to-date
  compileBuildDriverPhase
  setupCompileFlags: -package-db=/private/var/folders/8x/6h3nms2s34z7vwk5blbsz3100000gn/T/nix-build-helloworld-0.1.0.0.drv-0/setup-package.conf.d -j4 -threaded
  [1 of 1] Compiling Main             ( Setup.hs, /private/var/folders/8x/6h3nms2s34z7vwk5blbsz3100000gn/T/nix-build-helloworld-0.1.0.0.drv-0/Main.o )
  Linking Setup ...  
</pre>
</div>

<p>
build成功后会在当前目录下生成 <code>result</code> 目录，其结构如下：
</p>

<div class="org-src-container">
<pre class="src src-text">  result
  ├── bin
  │   └── helloworld-exe
  ├── lib
  │   ├── ghc-8.6.5
  │   │   ├── package.conf.d
  │   │   │   └── helloworld-0.1.0.0-5AFk17aNCLW4CrcpWxCXgp.conf
  │   │   └── x86_64-osx-ghc-8.6.5
  │   │       ├── helloworld-0.1.0.0-5AFk17aNCLW4CrcpWxCXgp
  │   │       │   ├── Lib.dyn_hi
  │   │       │   ├── Lib.hi
  │   │       │   ├── Lib.p_hi
  │   │       │   ├── Paths_helloworld.dyn_hi
  │   │       │   ├── Paths_helloworld.hi
  │   │       │   ├── Paths_helloworld.p_hi
  │   │       │   ├── libHShelloworld-0.1.0.0-5AFk17aNCLW4CrcpWxCXgp.a
  │   │       │   └── libHShelloworld-0.1.0.0-5AFk17aNCLW4CrcpWxCXgp_p.a
  │   │       └── libHShelloworld-0.1.0.0-5AFk17aNCLW4CrcpWxCXgp-ghc8.6.5.dylib
  │   └── links
  └── nix-support
      └── propagated-build-inputs

  8 directories, 12 files  
</pre>
</div>

<p>
确认build结果：
</p>

<div class="org-src-container">
<pre class="src src-text">  ❯ result/bin/helloworld-exe
  someFunc  
</pre>
</div>

<p>
实际上这个result是一个软链接
</p>

<div class="org-src-container">
<pre class="src src-text">  ❯ readlink result
  /nix/store/zdp1n3yifw6ikpn8hjsza40iwdmk5fnz-helloworld-0.1.0.0  
</pre>
</div>

<p>
此时再执行一遍 <code>nix-build</code> 会发现nix又会重新build一遍
</p>

<div class="org-src-container">
<pre class="src src-text">  ❯ nix-build
  these derivations will be built:
    /nix/store/43qdjaq019p4w81hqqds7wysbxaz0w4x-helloworld-0.1.0.0.drv
  building '/nix/store/43qdjaq019p4w81hqqds7wysbxaz0w4x-helloworld-0.1.0.0.drv'...
  setupCompilerEnvironmentPhase
  Build with /nix/store/kdmykixl5nafbygjp5i8a6b4iclmfm1l-ghc-8.6.5.
  unpacking sources
  unpacking source archive /nix/store/smxcdw5xy2kdmdn2931vgny4l7cxxq65-helloworld
  source root is helloworld
  patching sources
  helloworld.cabal is up-to-date
  compileBuildDriverPhase
  setupCompileFlags: -package-db=/private/var/folders/8x/6h3nms2s34z7vwk5blbsz3100000gn/T/nix-build-helloworld-0.1.0.0.drv-0/setup-package.conf.d -j4 -threaded
  [1 of 1] Compiling Main             ( Setup.hs, /private/var/folders/8x/6h3nms2s34z7vwk5blbsz3100000gn/T/nix-build-helloworld-0.1.0.0.drv-0/Main.o )
  Linking Setup ...
</pre>
</div>

<p>
明明没有任何变更为什么会重新编译，问题出在 helloworld.nix 文件的第五行。
</p>

<div class="org-src-container">
<pre class="src src-nix">  src = ./.;
</pre>
</div>

<p>
这里定义了当前目录所有文件为源码文件，第一次build时生成了result文件，所以文件夹内容有改变，所以就会认为文件变化，就会重新build。
</p>

<p>
这里可以使用nix内置函数，过滤掉软链接：
</p>

<div class="org-src-container">
<pre class="src src-nix">  src = builtins.filterSource (path: type: type != "symlink") ./.;
</pre>
</div>

<p>
更通用的是可以使用gitignore来过滤非源码文件，修改helloworld.nix：
</p>

<div class="org-src-container">
<pre class="src src-nix"><span class="linenr"> 1: </span>  { nix-gitignore, mkDerivation, base, hpack, stdenv }:
<span class="linenr"> 2: </span>  mkDerivation {
<span class="linenr"> 3: </span>    pname = "helloworld";
<span class="linenr"> 4: </span>    version = "0.1.0.0";
<span class="linenr"> 5: </span>    src = nix-gitignore.gitignoreSourcePure [./.gitignore] ./.;
<span class="linenr"> 6: </span>    isLibrary = true;
<span class="linenr"> 7: </span>    isExecutable = true;
<span class="linenr"> 8: </span>    libraryHaskellDepends = [ base ];
<span class="linenr"> 9: </span>    libraryToolDepends = [ hpack ];
<span class="linenr">10: </span>    executableHaskellDepends = [ base ];
<span class="linenr">11: </span>    testHaskellDepends = [ base ];
<span class="linenr">12: </span>    prePatch = "hpack";
<span class="linenr">13: </span>    homepage = "https://github.com/githubuser/helloworld#readme";
<span class="linenr">14: </span>    license = stdenv.lib.licenses.bsd3;
<span class="linenr">15: </span>  }  
</pre>
</div>
</div>
</div>

<div id="outline-container-org5e00ecb" class="outline-2">
<h2 id="org5e00ecb">添加shell.nix文件</h2>
<div class="outline-text-2" id="text-org5e00ecb">
<blockquote>
<p>
nix-shell - start an interactive shell based on a Nix expression
</p>
</blockquote>

<p>
所以使用nix-shell就可以打开一个跟build时相同的环境。
</p>

<div class="org-src-container">
<pre class="src src-text">  ❯ nix-shell

  [nix-shell:~/src/github.com/shanexu/helloworld]$ ghc --version
  The Glorious Glasgow Haskell Compilation System, version 8.6.5

  [nix-shell:~/src/github.com/shanexu/helloworld]$
  /Users/shane/.nix-profile/bin/cabal
</pre>
</div>

<p>
默认nix-shell会找shell.nix和default.nix文件。
</p>

<p>
如果需要定制nix-shell，则可以自行编写shell.nix文件：
</p>

<div class="org-src-container">
<pre class="src src-nix"><span class="linenr"> 1: </span>  let
<span class="linenr"> 2: </span>    pkgs = import &lt;nixpkgs&gt; {};
<span class="linenr"> 3: </span>    default = (import ./default.nix);
<span class="linenr"> 4: </span>  in
<span class="linenr"> 5: </span>    pkgs.haskellPackages.shellFor {
<span class="linenr"> 6: </span>      name = "helloworld-shell";
<span class="linenr"> 7: </span>      packages = p: [default];
<span class="linenr"> 8: </span>      buildInputs = [
<span class="linenr"> 9: </span>        pkgs.cabal-install
<span class="linenr">10: </span>        pkgs.haskellPackages.apply-refact
<span class="linenr">11: </span>        pkgs.haskellPackages.hlint
<span class="linenr">12: </span>        pkgs.haskellPackages.stylish-haskell
<span class="linenr">13: </span>        pkgs.haskellPackages.hasktags
<span class="linenr">14: </span>        pkgs.haskellPackages.hoogle
<span class="linenr">15: </span>        pkgs.haskellPackages.hindent
<span class="linenr">16: </span>      ];
<span class="linenr">17: </span>    }
</pre>
</div>

<p>
这里在nix-shell里面安装了cabal，hlint等工具：
</p>

<div class="org-src-container">
<pre class="src src-text">  ❯ nix-shell

  [nix-shell:~/src/github.com/shanexu/helloworld]$ which cabal
  /nix/store/h4wzzvjzpggyprf40n20y1adzbvhh9xj-cabal-install-3.0.0.0/bin/cabal

  [nix-shell:~/src/github.com/shanexu/helloworld]$ which hlint
  /nix/store/8s5q0l63cs2fn0hlwnjsps7iwh8ma5w8-hlint-2.2.3/bin/hlint  
</pre>
</div>
</div>
</div>

<div id="outline-container-org40f04b1" class="outline-2">
<h2 id="org40f04b1">安装HIE</h2>
<div class="outline-text-2" id="text-org40f04b1">
<p>
安装cachix
</p>

<div class="org-src-container">
<pre class="src src-shell-script">  nix-env -iA cachix -f https://cachix.org/api/v1/install
</pre>
</div>

<p>
使用预编译缓存
</p>

<div class="org-src-container">
<pre class="src src-shell-script">  cachix use all-hies
</pre>
</div>

<p>
可以在全局环境安装HIE
</p>

<div class="org-src-container">
<pre class="src src-shell-script">  nix-env -iA selection --arg selector 'p: { inherit (p) ghc865; }' -f https://github.com/infinisil/all-hies/tarball/master
</pre>
</div>

<p>
也可以加入到shell.nix中
</p>

<div class="org-src-container">
<pre class="src src-nix"><span class="linenr"> 1: </span>  let
<span class="linenr"> 2: </span>    pkgs = import &lt;nixpkgs&gt; {};
<span class="linenr"> 3: </span>    default = (import ./default.nix);
<span class="linenr"> 4: </span>    all-hie = (import (fetchTarball "https://github.com/infinisil/all-hies/tarball/master") {});
<span class="linenr"> 5: </span>  in
<span class="linenr"> 6: </span>    pkgs.haskellPackages.shellFor {
<span class="linenr"> 7: </span>      name = "helloworld-shell";
<span class="linenr"> 8: </span>      packages = p: [default];
<span class="linenr"> 9: </span>      buildInputs = [
<span class="linenr">10: </span>        pkgs.cabal-install
<span class="linenr">11: </span>        pkgs.haskellPackages.apply-refact
<span class="linenr">12: </span>        pkgs.haskellPackages.hlint
<span class="linenr">13: </span>        pkgs.haskellPackages.stylish-haskell
<span class="linenr">14: </span>        pkgs.haskellPackages.hasktags
<span class="linenr">15: </span>        pkgs.haskellPackages.hoogle
<span class="linenr">16: </span>        pkgs.haskellPackages.hindent
<span class="linenr">17: </span>        (all-hie.selection { selector = p: { inherit (p) ghc865; }; })
<span class="linenr">18: </span>      ];
<span class="linenr">19: </span>    }
</pre>
</div>
</div>
</div>

<div id="outline-container-orge54b062" class="outline-2">
<h2 id="orge54b062">nix-shell和direnv</h2>
<div class="outline-text-2" id="text-orge54b062">
<p>
nix-shell默认使用bash，但是我平时都用 <a href="https://github.com/robbyrussell/oh-my-zsh">oh-my-zsh</a> 。direnv已经支持nix，可以通过stdlib的use_nix函数，启用nix的环境配置。只要在当前目录下增加.envrc文件便可启用。
</p>
<div class="org-src-container">
<pre class="src src-text">  use_nix
</pre>
</div>

<p>
但是每次进入目录都会非常慢。
</p>

<div class="org-src-container">
<pre class="src src-text">  ❯ direnv allow
  direnv: loading .envrc
  direnv: ([/usr/local/bin/direnv export zsh]) is taking a while to execute. Use CTRL-C to give up.  
</pre>
</div>

<p>
查看stdlib中的use_nix函数：
</p>

<div class="org-src-container">
<pre class="src src-shell-script"><span class="linenr"> 1: </span>  # Usage: use_nix [...]
<span class="linenr"> 2: </span>  #
<span class="linenr"> 3: </span>  # Load environment variables from `nix-shell`.
<span class="linenr"> 4: </span>  # If you have a `default.nix` or `shell.nix` these will be
<span class="linenr"> 5: </span>  # used by default, but you can also specify packages directly
<span class="linenr"> 6: </span>  # (e.g `use nix -p ocaml`).
<span class="linenr"> 7: </span>  #
<span class="linenr"> 8: </span>  use_nix() {
<span class="linenr"> 9: </span>    direnv_load nix-shell --show-trace "$@" --run "$(join_args "$direnv" dump)"
<span class="linenr">10: </span>    if [[ $# == 0 ]]; then
<span class="linenr">11: </span>      watch_file default.nix
<span class="linenr">12: </span>      watch_file shell.nix
<span class="linenr">13: </span>    fi
<span class="linenr">14: </span>  }  
</pre>
</div>

<p>
可见每次进入目录的时候都需要执行nix-shell命令，这其实非常慢。
</p>

<p>
修改 <code>~/.direnvrc</code> 增加 <code>use_nix</code> 函数，覆盖stdlib中的方法。这个方法根据目录中的shell.nix和default.nix文件的hash值，在.direnv中保存nix-shell环境的缓存。同时为了防止 <code>nix-store --gc</code> 回收 <code>nix-shell</code> 的依赖包。在 .direnv 目录里面生成nix的gcroots，也就是几个软链接。
</p>

<div class="org-src-container">
<pre class="src src-shell-script"><span class="linenr"> 1: </span>  use_nix() {
<span class="linenr"> 2: </span>      local path="$(nix-instantiate --find-file nixpkgs)"
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>      if [ -f "${path}/.version-suffix" ]; then
<span class="linenr"> 5: </span>          local version="$(&lt; $path/.version-suffix)"
<span class="linenr"> 6: </span>      elif [ -f "${path}/.git" ]; then
<span class="linenr"> 7: </span>          local version="$(&lt; $(&lt; ${path}/.git/HEAD))"
<span class="linenr"> 8: </span>      fi
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>      local cache=".direnv/cache-${version:-unknown}"
<span class="linenr">11: </span>
<span class="linenr">12: </span>      local update_drv=0
<span class="linenr">13: </span>      if [[ ! -e "$cache" ]] || \
<span class="linenr">14: </span>             [[ "$HOME/.direnvrc" -nt "$cache" ]] || \
<span class="linenr">15: </span>             [[ .envrc -nt "$cache" ]] || \
<span class="linenr">16: </span>             [[ default.nix -nt "$cache" ]] || \
<span class="linenr">17: </span>             [[ shell.nix -nt "$cache" ]];
<span class="linenr">18: </span>      then
<span class="linenr">19: </span>          [ -d .direnv ] || mkdir .direnv
<span class="linenr">20: </span>          nix-shell --show-trace "$@" --run "\"$direnv\" dump bash" &gt; "$cache"
<span class="linenr">21: </span>          update_drv=1
<span class="linenr">22: </span>      else
<span class="linenr">23: </span>          log_status using cached derivation
<span class="linenr">24: </span>      fi
<span class="linenr">25: </span>      local term_backup=$TERM path_backup=$PATH
<span class="linenr">26: </span>      if [ -n ${TMPDIR+x} ]; then
<span class="linenr">27: </span>          local tmp_backup=$TMPDIR
<span class="linenr">28: </span>      fi
<span class="linenr">29: </span>
<span class="linenr">30: </span>      eval "$(&lt; $cache)"
<span class="linenr">31: </span>      export PATH=$PATH:$path_backup TERM=$term_backup TMPDIR=$tmp_backup
<span class="linenr">32: </span>      if [ -n ${tmp_backup+x} ]; then
<span class="linenr">33: </span>          export TMPDIR=${tmp_backup}
<span class="linenr">34: </span>      else
<span class="linenr">35: </span>          unset TMPDIR
<span class="linenr">36: </span>      fi
<span class="linenr">37: </span>
<span class="linenr">38: </span>      if [ "$out" ] &amp;&amp; (( $update_drv )); then
<span class="linenr">39: </span>          local drv_link=".direnv/shell.drv"
<span class="linenr">40: </span>          local drv_dep_link=".direnv/shell.dep"
<span class="linenr">41: </span>          local drv="$(nix show-derivation $out | grep -E -o -m1 '/nix/store/.*.drv')"
<span class="linenr">42: </span>          local stripped_pwd=${PWD/\//}
<span class="linenr">43: </span>          local escaped_pwd=${stripped_pwd//-/--}
<span class="linenr">44: </span>          local escaped_pwd=${escaped_pwd//\//-}
<span class="linenr">45: </span>          ln -fs "$drv" "$drv_link"
<span class="linenr">46: </span>          ln -fs "$PWD/$drv_link" "/nix/var/nix/gcroots/per-user/$LOGNAME/$escaped_pwd"
<span class="linenr">47: </span>          rm -f ${drv_dep_link}*
<span class="linenr">48: </span>          nix-store --indirect --add-root $drv_dep_link --realise $(nix-store --query --references $drv_link)
<span class="linenr">49: </span>          log_status renewed cache and derivation link
<span class="linenr">50: </span>      fi
<span class="linenr">51: </span>
<span class="linenr">52: </span>      if [[ $# = 0 ]]; then
<span class="linenr">53: </span>          watch_file default.nix
<span class="linenr">54: </span>          watch_file shell.nix
<span class="linenr">55: </span>      fi
<span class="linenr">56: </span>  }
</pre>
</div>
</div>
</div>

<div id="outline-container-org4946a53" class="outline-2">
<h2 id="org4946a53">配置emacs(spacemacs)</h2>
<div class="outline-text-2" id="text-org4946a53">
<p>
我使用的是 <a href="https://github.com/syl20bnr/spacemacs/">spacemacs</a> 的 develop 分支。
</p>

<p>
为了是emacs和direnv能够很好结合可以额外增加包，并在 <code>.spacemacs</code> 文件中 <code>dotspacemacs/user-config</code> 函数中添加配置。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="linenr">1: </span>  ;; direnv-mode
<span class="linenr">2: </span>  (use-package direnv
<span class="linenr">3: </span>    :config
<span class="linenr">4: </span>    (direnv-mode))
</pre>
</div>


<div id="org813b9ae" class="figure">
<p><img src="/assets/blog/2019/11/07/learning-haskell-with-nix-and-emacs/68374271-7886ff00-013c-11ea-92aa-fc27ff89f413.png" alt="68374271-7886ff00-013c-11ea-92aa-fc27ff89f413.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org1205bfe" class="outline-2">
<h2 id="org1205bfe">仓库地址</h2>
<div class="outline-text-2" id="text-org1205bfe">
<p>
<a href="https://github.com/shanexu/helloworld">https://github.com/shanexu/helloworld</a>
</p>
</div>
</div>

<div id="outline-container-orgc83a1fb" class="outline-2">
<h2 id="orgc83a1fb">参考文档</h2>
<div class="outline-text-2" id="text-orgc83a1fb">
<p>
<a href="https://nixos.org/nix/manual">https://nixos.org/nix/manual</a>
</p>

<p>
<a href="https://github.com/Gabriel439/haskell-nix">https://github.com/Gabriel439/haskell-nix</a>
</p>

<p>
<a href="https://github.com/fghibellini/nix-haskell-monorepo">https://github.com/fghibellini/nix-haskell-monorepo</a>
</p>

<p>
<a href="https://github.com/haskell/haskell-ide-engine">https://github.com/haskell/haskell-ide-engine</a>
</p>

<p>
<a href="https://github.com/Infinisil/all-hies">https://github.com/Infinisil/all-hies</a>
</p>

<p>
<a href="https://github.com/NixOS/nix/issues/2208#issuecomment-412262911">https://github.com/NixOS/nix/issues/2208#issuecomment-412262911</a>
</p>

<p>
<a href="https://github.com/direnv/direnv/wiki/Nix">https://github.com/direnv/direnv/wiki/Nix</a>
</p>

<p>
<a href="https://github.com/wbolster/emacs-direnv">https://github.com/wbolster/emacs-direnv</a>
</p>

<p>
<a href="https://docs.haskellstack.org/en/stable/README/">https://docs.haskellstack.org/en/stable/README/</a>
</p>

<p>
<a href="https://www.haskell.org/cabal/users-guide/index.html">https://www.haskell.org/cabal/users-guide/index.html</a>
</p>

<p>
<a href="https://www.sam.today/blog/environments-with-nix-shell-learning-nix-pt-1/">https://www.sam.today/blog/environments-with-nix-shell-learning-nix-pt-1/</a>
</p>

<p>
<a href="https://www.youtube.com/watch?v=61MuMY9XFNo">Reading Nix Expression Zimbatm</a>
</p>
</div>
</div>

</div>
</div>
    <div>
      <div class="post-meta">
        <span title="post date" class="post-info">2019-11-07</span>
        <span title="last modification date" class="post-info">2021-02-14</span>
        <span title="tags" class="post-info"><a href="/tags/haskell/">haskell</a>, <a href="/tags/nix/">nix</a></span>
        <span title="author" class="post-info">shanexu</span>
      </div>
      <section>
        <h1>Comments</h1>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
          //var disqus_developer = 1;
          var disqus_identifier = "/blog/2019/11/07/learning-haskell-with-nix-and-emacs";
          var disqus_url = "https://xusheng.org/blog/2019/11/07/learning-haskell-with-nix-and-emacs";
          var disqus_shortname = 'shanexu';
          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="//disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
       <div id="hashover"></div>
       <script type="text/javascript" src="/hashover.php"></script>
       <noscript>You must have JavaScript enabled to use the comments.</noscript>
      </section>
      <script src="//code.jquery.com/jquery-latest.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.js"></script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="/media/js/main.js"></script>
      <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-74684473-1']);
        _gaq.push(['_trackPageview']);
        (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
      </script>
      <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 29.x (<a href="http://orgmode.org">Org mode</a> 9.x)</p>
        <p>
          Copyright &copy; 2012 - <span id="footerYear"></span> <a href="mailto:xusheng0711 &lt;at&gt; gmail &lt;dot&gt; com">shanexu</a>
          &nbsp;&nbsp;-&nbsp;&nbsp;
          Powered by <a href="https://github.com/kelvinh/org-page" target="_blank">org-page</a>
          <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
        </p>
      </div>
    </div>

  </body>
</html>
