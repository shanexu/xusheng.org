<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>golang aop的一种实现方法 - org-page</title>
    <meta charset="utf-8" />
    <meta name="author" content="shanexu" />
    <meta name="description" content="golang aop的一种实现方法" />
    <meta name="keywords" content="golang, aop" />
    <link rel="stylesheet" href="/media/css/main.css" type="text/css">
    <link rel="stylesheet" href="/media/css/prettify.css" type="text/css">
  </head>
  <body class="container">
    <div>
      <header class="masthead">
        <h1 class="masthead-title">
          <a href="/">org-page</a>
        </h1>
        <p>static site generator</p>
        <ul>
          <li><a href="/blog/">Blog</a></li>
          <li><a href="/tags/">Tags</a></li>
          <li><a href="/about/">About</a></li>
          <li><a href="https://github.com/shanexu">GitHub</a></li>
          <li><a href="/rss.xml">RSS</a></li>
        </ul>
        <form method="get" id="searchform" action="//www.google.com/search">
          <input type="text" class="field" name="q" id="s" placeholder="Search">
          <input type="hidden" name="as_sitesearch" value="xusheng.org">
        </form>
        <img class="avatar" src="https://avatars.githubusercontent.com/u/1257453?s=400&amp;u=887a49b5ff99794452aa0bc3772fe113cc6e962a&amp;v=4" />
      </header>
    </div>

<div>
<div class="post">
<h1>golang aop的一种实现方法</h1>

<div id="outline-container-org95b03d9" class="outline-2">
<h2 id="org95b03d9">序</h2>
<div class="outline-text-2" id="text-org95b03d9">
<p>
实际这个标题有点夸张了。我原本也不想实现golang的aop，也无意去实现。我的出发点仅仅是APM(Application Performance Management)。我们总说golang是一门怎么怎么神奇好用的语言，然而仅仅是一个aop都难以优雅地实现。再比如，opentracing，设计了一整套api，做分布式调用链追踪，其中包括java、golang等语言，实际上纯用java的人可能根本不需要用opentracing这套东西。java的字节码增强实在是太好用了。根本就不需要这样繁琐地在代码中显示地调用opentracing的api。所以golang有没有类似java这样的字节码增强的方法呢？肯定没有啊。
</p>

<p>
我们来了解下go代码是怎样变成机器码的。
</p>

<p>
<a href="https://getstream.io/blog/how-a-go-program-compiles-down-to-machine-code/">How a Go Program Compiles down to Machine Code</a>
</p>

<p>
大意是：
</p>

<div class="org-src-container">
<pre class="src src-text">*.go -&gt; AST(Abstract Syntax Tree) -&gt; SSA(Static Single Assignment) -&gt; machine-specific SSA -&gt; Machine Code
</pre>
</div>

<p>
显然，在AST到SSA这个过程中，可以通过修改语法树的方式，达到类似java的字节码增强的效果。所以需要改golang的编译器。
</p>

<p>
提起APM，两年前做APM调研的时候调研了OneAPM的产品，据当时的销售说，当时无人做golang相关的APM产品，时隔三年，OneAPM也支持了golang了。从golang agent的 <a href="http://docs-ai.oneapm.com/agent/go/Goinstall.html">安装手册</a> 手册来看，OneAPM应该是用了类似jaeger的方案，需要手工埋点。
</p>
</div>
</div>

<div id="outline-container-org4f9c6fd" class="outline-2">
<h2 id="org4f9c6fd">开发环境准备</h2>
<div class="outline-text-2" id="text-org4f9c6fd">
<p>
工欲善其事必先利其器，我敬佩那些用vim和emacs写golang代码的大神（虽然我也用emacs写golang代码），但是面对golang源码这个大工程，我还是选择使用GoLand。因为牵涉到很多环境变量的切换，推荐使用 <a href="https://direnv.net/">direnv</a> 方便切换配置。
</p>
</div>

<div id="outline-container-org2d2c700" class="outline-3">
<h3 id="org2d2c700">准备源代码</h3>
<div class="outline-text-3" id="text-org2d2c700">
<div class="org-src-container">
<pre class="src src-shell">mkdir -p $HOME/src/github.com/golang
cd $HOME/src/github.com/golang
git clone https://github.com/golang/go.git
cd $HOME/src/github.com/golang/go/src
echo 'export GOROOT=$HOME/src/github.com/golang/go
export PATH=$GOROOT/bin:$PATH
export GOBIN=$GOROOT/bin' &gt; .envrc
direnv allow
</pre>
</div>
</div>
</div>

<div id="outline-container-org11dcda8" class="outline-3">
<h3 id="org11dcda8">安装BOOTSTRAP环境（go编译器通过go语言编译，正如gcc通过gcc编译一般）</h3>
<div class="outline-text-3" id="text-org11dcda8">
<div class="org-src-container">
<pre class="src src-shell">mkdir $HOME/gos
cd $HOME/gos
curl https://dl.google.com/go/go1.12.10.darwin-amd64.tar.gz | tar xvzf -
mv go go1.12.10
cd $HOME/src/github.com/golang/go/src
echo 'export GOROOT_BOOTSTRAP=$HOME/gos/go1.12.10' &gt;&gt; .envrc
direnv allow
</pre>
</div>
</div>
</div>

<div id="outline-container-org8657373" class="outline-3">
<h3 id="org8657373">切换到最新的tag，并创建一个分支</h3>
<div class="outline-text-3" id="text-org8657373">
<div class="org-src-container">
<pre class="src src-shell">cd $HOME/src/github.com/golang/go
git checkout go1.13.1
git checkout -b go1.13.1-playground
</pre>
</div>
</div>
</div>

<div id="outline-container-org92bbcf2" class="outline-3">
<h3 id="org92bbcf2">首次尝试编译go编译器</h3>
<div class="outline-text-3" id="text-org92bbcf2">
<div class="org-src-container">
<pre class="src src-shell">cd $HOME/src/github.com/golang/go/src
./make.bash
</pre>
</div>

<p>
会看到如下的输出
</p>
<div class="org-src-container">
<pre class="src src-text">Building Go cmd/dist using /Users/shane/gos/go1.12.10.
Building Go toolchain1 using /Users/shane/gos/go1.12.10.
Building Go bootstrap cmd/go (go_bootstrap) using Go toolchain1.
Building Go toolchain2 using go_bootstrap and Go toolchain1.
Building Go toolchain3 using go_bootstrap and Go toolchain2.
Building packages and commands for darwin/amd64.
---
Installed Go for darwin/amd64 in /Users/shane/src/github.com/golang/go
Installed commands in /Users/shane/src/github.com/golang/go/bin
</pre>
</div>

<p>
验证编译
</p>
<div class="org-src-container">
<pre class="src src-shell">which go
go version
</pre>
</div>
</div>
</div>

<div id="outline-container-org81c2d27" class="outline-3">
<h3 id="org81c2d27">GoLand设置</h3>
<div class="outline-text-3" id="text-org81c2d27">
</div>
<div id="outline-container-orgf7dc9b3" class="outline-4">
<h4 id="orgf7dc9b3">创建项目</h4>
<div class="outline-text-4" id="text-orgf7dc9b3">
<p>
File -&gt; Open 选择工程根目录
</p>


<div id="orge11f9b3" class="figure">
<p><img src="/assets/blog/2019/10/09/golang-aop/66475611-3a39e980-ea83-11e9-802e-3b118d1ac906.png" alt="66475611-3a39e980-ea83-11e9-802e-3b118d1ac906.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org968e4cd" class="outline-4">
<h4 id="org968e4cd">设置GOROOT</h4>
<div class="outline-text-4" id="text-org968e4cd">
<p>
<code>$HOME/src/github.com/golang/go</code>
</p>


<div id="orgec29861" class="figure">
<p><img src="/assets/blog/2019/10/09/golang-aop/66475821-a4528e80-ea83-11e9-970b-8982bafbab77.png" alt="66475821-a4528e80-ea83-11e9-970b-8982bafbab77.png" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org50efb7d" class="outline-3">
<h3 id="org50efb7d">创建一个playground项目，用于测试编译</h3>
<div class="outline-text-3" id="text-org50efb7d">
</div>
<div id="outline-container-org2b2971b" class="outline-4">
<h4 id="org2b2971b">clone我的测试项目</h4>
<div class="outline-text-4" id="text-org2b2971b">
<div class="org-src-container">
<pre class="src src-shell">cd $HOME/src/github.com/shanexu
git clone https://github.com/shanexu/go-playground.git
</pre>
</div>
</div>
</div>

<div id="outline-container-org07289bd" class="outline-4">
<h4 id="org07289bd">配置环境变量</h4>
<div class="outline-text-4" id="text-org07289bd">
<div class="org-src-container">
<pre class="src src-shell">cd $HOME/src/github.com/shanexu/go-playground
echo 'export GOROOT=$HOME/src/github.com/golang/go
export PATH=$GOROOT/bin:$PATH
export GOBIN=$(pwd)/bin' &gt; .envrc
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgc57165b" class="outline-3">
<h3 id="orgc57165b">至此整个开发环境算是搭建成功了</h3>
</div>
</div>

<div id="outline-container-orgfb9aba5" class="outline-2">
<h2 id="orgfb9aba5">go build 过程分析</h2>
<div class="outline-text-2" id="text-orgfb9aba5">
<div class="org-src-container">
<pre class="src src-shell">cd $HOME/src/github.com/shanexu/go-playground
go build -o bin/helloworld helloworld/main.go
</pre>
</div>

<p>
先从 <code>go build</code> 命令开始。go命令本身就是多个子命令的入口，比如我们现在要研究的build命令，就是他的一个子命令，其源码在 <code>src/cmd/go/internal/work/build.go</code> 中。
</p>
<div class="org-src-container">
<pre class="src src-go"><span class="linenr">23: </span>var CmdBuild = &amp;base.Command{
<span class="linenr">24: </span>	UsageLine: "go build [-o output] [-i] [build flags] [packages]",
<span class="linenr">25: </span>	Short:     "compile packages and dependencies",  
</pre>
</div>

<p>
配置一个运行配置如下图所示：
<img src="/assets/blog/2019/10/09/golang-aop/66554844-37033400-eb3d-11e9-8558-f42b8458b1e7.png" alt="66554844-37033400-eb3d-11e9-8558-f42b8458b1e7.png" />
</p>

<p>
经过断点和肉眼调试，go build过程大致如下：
</p>

<div class="org-src-container">
<pre class="src src-dot">digraph G {
    "main.main at main.go" -&gt; "cmd/go/internal/work.runBuild at build.go"
    "cmd/go/internal/work.runBuild at build.go" -&gt; "cmd/go/internal/work.(*Builder).Do at exec.go"
    "cmd/go/internal/work.(*Builder).Do at exec.go" -&gt; "writeActionGraph"
    "cmd/go/internal/work.(*Builder).Do at exec.go" -&gt; "cmd/go/internal/work.(*Builder).Do.func3 at exec.go:177 handle(a)"
    "cmd/go/internal/work.(*Builder).Do.func3 at exec.go:177 handle(a)" -&gt; "cmd/go/internal/work.(*Builder).Do.func2 at exec.go:117 err = a.Func(b, a)"
    "cmd/go/internal/work.(*Builder).Do.func2 at exec.go:117 err = a.Func(b, a)" -&gt; "cmd/go/internal/work.(*Builder).build at exec.go:380"
    "cmd/go/internal/work.(*Builder).Do.func2 at exec.go:117 err = a.Func(b, a)" -&gt; "cmd/go/internal/work.(*Builder).link at exec.go:1183"
    "cmd/go/internal/work.(*Builder).Do.func2 at exec.go:117 err = a.Func(b, a)" -&gt; "cmd/go/internal/work.BuildInstallFunc at exec.go:1438"
}
</pre>
</div>

<p>
<code>main</code> 方法调用， <code>runBuild</code> 方法， <code>runBuild</code> 再调用 <code>*Builder.Do</code> 方法，在 <code>Do</code> 方法中根据 <code>Action</code> 的依赖关系，调用 <code>Action</code> 的 <code>Func</code> 方法。这里有个 <code>writeActionGraph</code> 方法，这个方法会打印 <code>action</code> 的关系图，但是由一个命令行参数控制。
</p>

<div class="org-src-container">
<pre class="src src-go"><span class="linenr">243: </span>	// Undocumented, unstable debugging flags.
<span class="linenr">244: </span>	cmd.Flag.StringVar(&amp;cfg.DebugActiongraph, "debug-actiongraph", "", "")
</pre>
</div>

<p>
完整的命令行如下，其中 <code>-p 1</code> 表示执行 <code>action</code> 时的并发度为1。
</p>

<div class="org-src-container">
<pre class="src src-shell">go build -debug-actiongraph /tmp/build.txt -p 1 -v -o bin/helloworld helloworld/main.go
</pre>
</div>

<p>
我们得到完整的 <code>actionGraph</code> 内容如下：
</p>

<script src="https://gist.github.com/shanexu/1277c298054e2489bb923b3233cf723c.js"></script>  

<p>
转成图，如下：
</p>

<div class="org-src-container">
<pre class="src src-dot">digraph G {
"0 link-install command-line-arguments" -&gt; "1 link command-line-arguments"
"1 link command-line-arguments" -&gt; "2 build command-line-arguments"
"1 link command-line-arguments" -&gt; "3 build context"
"1 link command-line-arguments" -&gt; "4 build fmt"
"1 link command-line-arguments" -&gt; "5 build runtime"
"1 link command-line-arguments" -&gt; "6 build errors"
"1 link command-line-arguments" -&gt; "7 build internal/reflectlite"
"1 link command-line-arguments" -&gt; "8 build sync"
"1 link command-line-arguments" -&gt; "9 build time"
"1 link command-line-arguments" -&gt; "10 build internal/fmtsort"
"1 link command-line-arguments" -&gt; "11 build io"
"1 link command-line-arguments" -&gt; "12 build math"
"1 link command-line-arguments" -&gt; "13 build os"
"1 link command-line-arguments" -&gt; "14 build reflect"
"1 link command-line-arguments" -&gt; "15 build strconv"
"1 link command-line-arguments" -&gt; "16 build unicode/utf8"
"1 link command-line-arguments" -&gt; "17 build internal/bytealg"
"1 link command-line-arguments" -&gt; "18 build internal/cpu"
"1 link command-line-arguments" -&gt; "19 build runtime/internal/atomic"
"1 link command-line-arguments" -&gt; "20 build runtime/internal/math"
"1 link command-line-arguments" -&gt; "21 build runtime/internal/sys"
"1 link command-line-arguments" -&gt; "22 build internal/race"
"1 link command-line-arguments" -&gt; "23 build sync/atomic"
"1 link command-line-arguments" -&gt; "24 build syscall"
"1 link command-line-arguments" -&gt; "25 build sort"
"1 link command-line-arguments" -&gt; "26 build math/bits"
"1 link command-line-arguments" -&gt; "27 build internal/oserror"
"1 link command-line-arguments" -&gt; "28 build internal/poll"
"1 link command-line-arguments" -&gt; "29 build internal/syscall/unix"
"1 link command-line-arguments" -&gt; "30 build internal/testlog"
"1 link command-line-arguments" -&gt; "31 build unicode"
"2 build command-line-arguments" -&gt; "3 build context"
"2 build command-line-arguments" -&gt; "4 build fmt"
"2 build command-line-arguments" -&gt; "5 build runtime"
"2 build command-line-arguments" -&gt; "32 nop "
"3 build context" -&gt; "6 build errors"
"3 build context" -&gt; "7 build internal/reflectlite"
"3 build context" -&gt; "8 build sync"
"3 build context" -&gt; "9 build time"
"4 build fmt" -&gt; "6 build errors"
"4 build fmt" -&gt; "10 build internal/fmtsort"
"4 build fmt" -&gt; "11 build io"
"4 build fmt" -&gt; "12 build math"
"4 build fmt" -&gt; "13 build os"
"4 build fmt" -&gt; "14 build reflect"
"4 build fmt" -&gt; "15 build strconv"
"4 build fmt" -&gt; "8 build sync"
"4 build fmt" -&gt; "16 build unicode/utf8"
"5 build runtime" -&gt; "17 build internal/bytealg"
"5 build runtime" -&gt; "18 build internal/cpu"
"5 build runtime" -&gt; "19 build runtime/internal/atomic"
"5 build runtime" -&gt; "20 build runtime/internal/math"
"5 build runtime" -&gt; "21 build runtime/internal/sys"
"5 build runtime" -&gt; "33 built-in package unsafe"
"6 build errors" -&gt; "7 build internal/reflectlite"
"7 build internal/reflectlite" -&gt; "5 build runtime"
"7 build internal/reflectlite" -&gt; "33 built-in package unsafe"
"8 build sync" -&gt; "22 build internal/race"
"8 build sync" -&gt; "5 build runtime"
"8 build sync" -&gt; "23 build sync/atomic"
"8 build sync" -&gt; "33 built-in package unsafe"
"9 build time" -&gt; "6 build errors"
"9 build time" -&gt; "5 build runtime"
"9 build time" -&gt; "8 build sync"
"9 build time" -&gt; "24 build syscall"
"9 build time" -&gt; "33 built-in package unsafe"
"10 build internal/fmtsort" -&gt; "14 build reflect"
"10 build internal/fmtsort" -&gt; "25 build sort"
"11 build io" -&gt; "6 build errors"
"11 build io" -&gt; "8 build sync"
"11 build io" -&gt; "23 build sync/atomic"
"12 build math" -&gt; "18 build internal/cpu"
"12 build math" -&gt; "26 build math/bits"
"12 build math" -&gt; "33 built-in package unsafe"
"13 build os" -&gt; "6 build errors"
"13 build os" -&gt; "27 build internal/oserror"
"13 build os" -&gt; "28 build internal/poll"
"13 build os" -&gt; "29 build internal/syscall/unix"
"13 build os" -&gt; "30 build internal/testlog"
"13 build os" -&gt; "11 build io"
"13 build os" -&gt; "5 build runtime"
"13 build os" -&gt; "8 build sync"
"13 build os" -&gt; "23 build sync/atomic"
"13 build os" -&gt; "24 build syscall"
"13 build os" -&gt; "9 build time"
"13 build os" -&gt; "33 built-in package unsafe"
"14 build reflect" -&gt; "12 build math"
"14 build reflect" -&gt; "5 build runtime"
"14 build reflect" -&gt; "15 build strconv"
"14 build reflect" -&gt; "8 build sync"
"14 build reflect" -&gt; "31 build unicode"
"14 build reflect" -&gt; "16 build unicode/utf8"
"14 build reflect" -&gt; "33 built-in package unsafe"
"15 build strconv" -&gt; "6 build errors"
"15 build strconv" -&gt; "17 build internal/bytealg"
"15 build strconv" -&gt; "12 build math"
"15 build strconv" -&gt; "26 build math/bits"
"15 build strconv" -&gt; "16 build unicode/utf8"
"17 build internal/bytealg" -&gt; "18 build internal/cpu"
"17 build internal/bytealg" -&gt; "33 built-in package unsafe"
"19 build runtime/internal/atomic" -&gt; "33 built-in package unsafe"
"20 build runtime/internal/math" -&gt; "21 build runtime/internal/sys"
"22 build internal/race" -&gt; "33 built-in package unsafe"
"23 build sync/atomic" -&gt; "33 built-in package unsafe"
"24 build syscall" -&gt; "6 build errors"
"24 build syscall" -&gt; "17 build internal/bytealg"
"24 build syscall" -&gt; "27 build internal/oserror"
"24 build syscall" -&gt; "22 build internal/race"
"24 build syscall" -&gt; "5 build runtime"
"24 build syscall" -&gt; "8 build sync"
"24 build syscall" -&gt; "33 built-in package unsafe"
"25 build sort" -&gt; "7 build internal/reflectlite"
"26 build math/bits" -&gt; "33 built-in package unsafe"
"27 build internal/oserror" -&gt; "6 build errors"
"28 build internal/poll" -&gt; "6 build errors"
"28 build internal/poll" -&gt; "11 build io"
"28 build internal/poll" -&gt; "5 build runtime"
"28 build internal/poll" -&gt; "8 build sync"
"28 build internal/poll" -&gt; "23 build sync/atomic"
"28 build internal/poll" -&gt; "24 build syscall"
"28 build internal/poll" -&gt; "9 build time"
"28 build internal/poll" -&gt; "33 built-in package unsafe"
"29 build internal/syscall/unix" -&gt; "24 build syscall"
"29 build internal/syscall/unix" -&gt; "33 built-in package unsafe"
"30 build internal/testlog" -&gt; "23 build sync/atomic"
"32 nop " -&gt; "3 build context"
"32 nop " -&gt; "4 build fmt"
"32 nop " -&gt; "5 build runtime"
"32 nop " -&gt; "6 build errors"
"32 nop " -&gt; "7 build internal/reflectlite"
"32 nop " -&gt; "8 build sync"
"32 nop " -&gt; "9 build time"
"32 nop " -&gt; "10 build internal/fmtsort"
"32 nop " -&gt; "11 build io"
"32 nop " -&gt; "12 build math"
"32 nop " -&gt; "13 build os"
"32 nop " -&gt; "14 build reflect"
"32 nop " -&gt; "15 build strconv"
"32 nop " -&gt; "16 build unicode/utf8"
"32 nop " -&gt; "17 build internal/bytealg"
"32 nop " -&gt; "18 build internal/cpu"
"32 nop " -&gt; "19 build runtime/internal/atomic"
"32 nop " -&gt; "20 build runtime/internal/math"
"32 nop " -&gt; "21 build runtime/internal/sys"
"32 nop " -&gt; "22 build internal/race"
"32 nop " -&gt; "23 build sync/atomic"
"32 nop " -&gt; "24 build syscall"
"32 nop " -&gt; "25 build sort"
"32 nop " -&gt; "26 build math/bits"
"32 nop " -&gt; "27 build internal/oserror"
"32 nop " -&gt; "28 build internal/poll"
"32 nop " -&gt; "29 build internal/syscall/unix"
"32 nop " -&gt; "30 build internal/testlog"
"32 nop " -&gt; "31 build unicode"
}
</pre>
</div>

<p>
观察 <code>actions[2].Cmd</code> 的内容。可见 <code>go build</code> 命令实际上是调用了对应系统（OS）架构（ARCH）的编译器命令（compile）来编译源代码的。
</p>
<div class="org-src-container">
<pre class="src src-json">[
  "/Users/shane/src/github.com/golang/go/pkg/tool/darwin_amd64/compile -o /var/folders/8x/6h3nms2s34z7vwk5blbsz3100000gn/T/go-build730813966/b001/_pkg_.a -trimpath \"/var/folders/8x/6h3nms2s34z7vwk5blbsz3100000gn/T/go-build730813966/b001=&gt;\" -p main -lang=go1.13 -complete -buildid z5Cb5jRJruTRtEF3nuzz/z5Cb5jRJruTRtEF3nuzz -goversion go1.13.1 -D _/Users/shane/src/github.com/shanexu/go-playground/helloworld -importcfg /var/folders/8x/6h3nms2s34z7vwk5blbsz3100000gn/T/go-build730813966/b001/importcfg -pack -c=12 /Users/shane/src/github.com/shanexu/go-playground/helloworld/main.go /var/folders/8x/6h3nms2s34z7vwk5blbsz3100000gn/T/go-build730813966/b001/_gomod_.go"
]
</pre>
</div>

<p>
命令行中有两个文件引起了我的兴趣： <code>importcfg</code> 和 <code>_gomod_.go</code> 。
</p>

<p>
然而，在go build命令运行结束后这些文件，都会被删除，为了防止这样的事情发生，我在go build运行的过程中增加了两个条件断点—— <code>cmd/go/internal/work/exec.go</code> 第117、119行，条件为 <code>a.json.ID =</code> 2= ，ID为2的action正是main.go的编译过程。
</p>

<p>
第117行开始执行Action，第119行Action执行结束。
</p>

<div class="org-src-container">
<pre class="src src-go"><span class="linenr">109: </span>	// Handle runs a single action and takes care of triggering
<span class="linenr">110: </span>	// any actions that are runnable as a result.
<span class="linenr">111: </span>	handle := func(a *Action) {
<span class="linenr">112: </span>		if a.json != nil {
<span class="linenr">113: </span>			a.json.TimeStart = time.Now()
<span class="linenr">114: </span>		}
<span class="linenr">115: </span>		var err error
<span class="linenr">116: </span>		if a.Func != nil &amp;&amp; (!a.Failed || a.IgnoreFail) {
<span class="linenr">117: </span>			err = a.Func(b, a)
<span class="linenr">118: </span>		}
<span class="linenr">119: </span>		if a.json != nil {
<span class="linenr">120: </span>			a.json.TimeDone = time.Now()
<span class="linenr">121: </span>		}
<span class="linenr">122: </span>
<span class="linenr">123: </span>		// The actions run in parallel but all the updates to the
<span class="linenr">124: </span>		// shared work state are serialized through b.exec.
</pre>
</div>

<p>
在代码运行到119行后就可以获取文件内容。
</p>

<p>
<code>_gomod_.go</code>
</p>
<div class="org-src-container">
<pre class="src src-go"><span class="linenr">1: </span>package main
<span class="linenr">2: </span>import _ "unsafe"
<span class="linenr">3: </span>//go:linkname __debug_modinfo__ runtime.modinfo
<span class="linenr">4: </span>var __debug_modinfo__ = "0w\xaf\f\x92t\b\x02A\xe1\xc1\a\xe6\xd6\x18\xe6path\tcommand-line-arguments\nmod\tgithub.com/shanexu/go-playground\t(devel)\t\n\xf92C1\x86\x18 r\x00\x82B\x10A\x16\xd8\xf2"
<span class="linenr">5: </span>	  
</pre>
</div>

<p>
<code>importcfg</code>
</p>
<div class="org-src-container">
<pre class="src src-text"># import config
packagefile context=/Users/shane/src/github.com/golang/go/pkg/darwin_amd64/context.a
packagefile fmt=/Users/shane/src/github.com/golang/go/pkg/darwin_amd64/fmt.a
packagefile runtime=/Users/shane/src/github.com/golang/go/pkg/darwin_amd64/runtime.a  
</pre>
</div>

<p>
有了这两个文件以及命令行参数后，我们就可以手动执行compile命令了。在GoLand里添加一个新的run configuration。
</p>


<div id="org852e93d" class="figure">
<p><img src="/assets/blog/2019/10/09/golang-aop/66623436-39b46680-ebdb-11e9-8591-bd88617988ea.png" alt="66623436-39b46680-ebdb-11e9-8591-bd88617988ea.png" />
</p>
</div>

<p>
其中 <code>Program arguments</code> 填入如下的值。
</p>

<div class="org-src-container">
<pre class="src src-text">-o /tmp/test/_pkg_.a -trimpath "/tmp/test=&gt;" -p main -complete -buildid dcQ8aaV0cfiucttoOzOD/dcQ8aaV0cfiucttoOzOD -D /Users/shane/src/github.com/shanexu/go-playground -importcfg /tmp/test/importcfg -pack -c=12 /Users/shane/src/github.com/shanexu/go-playground/helloworld/main.go /tmp/test/_gomod_.go
</pre>
</div>

<p>
至此我们就可以进入下一阶段的compile过程的分析了。
</p>
</div>
</div>

<div id="outline-container-org41901bd" class="outline-2">
<h2 id="org41901bd">compile 过程分析</h2>
<div class="outline-text-2" id="text-org41901bd">
<p>
从入口文件 <code>cmd/compile/main.go</code> 看起。
</p>

<div class="org-src-container">
<pre class="src src-go"><span class="linenr">40: </span>func main() {
<span class="linenr">41: </span>	// disable timestamps for reproducible output
<span class="linenr">42: </span>	log.SetFlags(0)
<span class="linenr">43: </span>	log.SetPrefix("compile: ")
<span class="linenr">44: </span>
<span class="linenr">45: </span>	archInit, ok := archInits[objabi.GOARCH]
<span class="linenr">46: </span>	if !ok {
<span class="linenr">47: </span>		fmt.Fprintf(os.Stderr, "compile: unknown architecture %q\n", objabi.GOARCH)
<span class="linenr">48: </span>		os.Exit(2)
<span class="linenr">49: </span>	}
<span class="linenr">50: </span>
<span class="linenr">51: </span>	gc.Main(archInit)
<span class="linenr">52: </span>	gc.Exit(0)
<span class="linenr">53: </span>}
</pre>
</div>

<p>
从第51行开始进入真正的编译过程，其主要逻辑在 <code>cmd/compile/internal/gc/main.go</code> 中。整个编译过程可以分成几个阶段。
</p>

<div class="org-src-container">
<pre class="src src-dot">digraph G {
"main.main at main.go:51" -&gt; "cmd/compile/internal/gc.Main at main.go:133 fe:init"
"main.main at main.go:51" -&gt; "cmd/compile/internal/gc.Main at main.go:508 fe:loadsys"
"main.main at main.go:51" -&gt; "cmd/compile/internal/gc.Main at main.go:511 fe:parse"
"main.main at main.go:51" -&gt; "cmd/compile/internal/gc.Main at main.go:534 fe:typecheck:top1"
"main.main at main.go:51" -&gt; "cmd/compile/internal/gc.Main at main.go:546 fe:typecheck:top2"
"main.main at main.go:51" -&gt; "cmd/compile/internal/gc.Main at main.go:553 fe:typecheck:func"
"main.main at main.go:51" -&gt; "cmd/compile/internal/gc.Main at main.go:589 fe:typecheck:capturevars"
"main.main at main.go:51" -&gt; "cmd/compile/internal/gc.Main at main.go:605 fe:typecheck:inlining"
"main.main at main.go:51" -&gt; "cmd/compile/internal/gc.Main at main.go:645 fe:typecheck:escapes"
"main.main at main.go:51" -&gt; "cmd/compile/internal/gc.Main at main.go:659 fe:typecheck:xclosures"
"main.main at main.go:51" -&gt; "cmd/compile/internal/gc.Main at main.go:680 fe:typecheck:compilefuncs"
"main.main at main.go:51" -&gt; "cmd/compile/internal/gc.Main at main.go:714 fe:typecheck:externaldcls"
"main.main at main.go:51" -&gt; "cmd/compile/internal/gc.Main at main.go:729 fe:typecheck:dumpobj"

"cmd/compile/internal/gc.Main at main.go:511 fe:parse" -&gt; "cmd/compile/internal/gc.parseFiles at noder.go:27"
"cmd/compile/internal/gc.parseFiles at noder.go:27" -&gt; "cmd/compile/internal/gc.parseFiles.func1 at noder.go:52"
"cmd/compile/internal/gc.parseFiles.func1 at noder.go:52" -&gt; "cmd/compile/internal/syntax.Parse at syntax.go:58"

"cmd/compile/internal/gc.parseFiles at noder.go:27" -&gt; "cmd/compile/internal/gc.parseFiles at noder.go:62"
"cmd/compile/internal/gc.parseFiles at noder.go:62" -&gt; "cmd/compile/internal/gc.(*noder).node at noder.go:237"

}  
</pre>
</div>

<p>
<code>main.go</code> 中有用于记录各步骤性能的 <code>timings</code> ，例如下面的几行代码。
</p>

<div class="org-src-container">
<pre class="src src-go"><span class="linenr">511: </span>	timings.Start("fe", "parse")
<span class="linenr">512: </span>	lines := parseFiles(flag.Args())
<span class="linenr">513: </span>	timings.Stop()
</pre>
</div>

<p>
在整个编译过程结束后，根据 <code>benchfile</code> 变量的值来选择是否输出bench结果。
</p>

<div class="org-src-container">
<pre class="src src-go"><span class="linenr">758: </span>	if benchfile != "" {
<span class="linenr">759: </span>		if err := writebench(benchfile); err != nil {
<span class="linenr">760: </span>			log.Fatalf("cannot write benchmark data: %v", err)
<span class="linenr">761: </span>		}
<span class="linenr">762: </span>	}
</pre>
</div>

<p>
所以加上如下的命令行参数，我们就能得到bench结果了。
</p>
<div class="org-src-container">
<pre class="src src-shell">  -bench=/tmp/test/bench.txt
</pre>
</div>

<p>
得到结果如下：
</p>
<div class="org-src-container">
<pre class="src src-text">commit: go1.13.1
goos: darwin
goarch: amd64
BenchmarkCompile:main:fe:init              1     889956 ns/op     10.22 %
BenchmarkCompile:main:fe:loadsys           1     323673 ns/op      3.72 %
BenchmarkCompile:main:fe:parse             1    1147490 ns/op     13.17 %    28 lines    24401 lines/s
BenchmarkCompile:main:fe:typecheck:top1    1     364684 ns/op      4.19 %
BenchmarkCompile:main:fe:typecheck:top2    1      19438 ns/op      0.22 %
BenchmarkCompile:main:fe:typecheck:func    1      36286 ns/op      0.42 %     2 funcs    55118 funcs/s
BenchmarkCompile:main:fe:capturevars       1        326 ns/op      0.00 %
BenchmarkCompile:main:fe:inlining          1    1799996 ns/op     20.67 %
BenchmarkCompile:main:fe:escapes           1     345481 ns/op      3.97 %
BenchmarkCompile:main:fe:xclosures         1     939317 ns/op     10.78 %
BenchmarkCompile:main:fe:subtotal          1    5866647 ns/op     67.36 %
BenchmarkCompile:main:be:compilefuncs      1    2145648 ns/op     24.63 %     2 funcs      932 funcs/s
BenchmarkCompile:main:be:externaldcls      1       1618 ns/op      0.02 %
BenchmarkCompile:main:be:dumpobj           1     666268 ns/op      7.65 %
BenchmarkCompile:main:be:subtotal          1    2813534 ns/op     32.30 %
BenchmarkCompile:main:unaccounted          1      29703 ns/op      0.34 %
BenchmarkCompile:main:total                1    8709884 ns/op    100.00 %  
</pre>
</div>

<p>
<code>cmd/compile/internal/gc.parseFiles.func1 at noder.go:52</code> 此处调用 <code>syntax.Parse</code> 对整个go文件进行语法解析。直觉上，只要修改这里生成的语法树，就能插入自定义代码了。
</p>
</div>
</div>

<div id="outline-container-org78e9325" class="outline-2">
<h2 id="org78e9325">编译期插入代码</h2>
<div class="outline-text-2" id="text-org78e9325">
<p>
在进入这一阶段之前可以先阅读下这篇 <a href="https://medium.com/justforfunc/understanding-go-programs-with-go-parser-c4e88a6edb87">Understanding Go programs with go/parser</a> ，对go的AST有一定的感性认识。
</p>

<p>
比如这个我们一直在默默测试的 <code>main.go</code>
</p>

<div class="org-src-container">
<pre class="src src-go"><span class="linenr"> 1: </span>package main
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span>import (
<span class="linenr"> 4: </span>	"context"
<span class="linenr"> 5: </span>	"fmt"
<span class="linenr"> 6: </span>)
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>func hello(ctx context.Context) {
<span class="linenr"> 9: </span>	fmt.Println("hello world")
<span class="linenr">10: </span>}
<span class="linenr">11: </span>
<span class="linenr">12: </span>func main() {
<span class="linenr">13: </span>	hello(context.Background())
<span class="linenr">14: </span>}
<span class="linenr">15: </span>
</pre>
</div>

<p>
经过 <code>go/parser.ParseFile</code> 
</p>
<div class="org-src-container">
<pre class="src src-go"><span class="linenr"> 1: </span>package main
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span>import (
<span class="linenr"> 4: </span>	"go/parser"
<span class="linenr"> 5: </span>	"go/token"
<span class="linenr"> 6: </span>	"io/ioutil"
<span class="linenr"> 7: </span>	"os"
<span class="linenr"> 8: </span>	"path/filepath"
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>	"github.com/davecgh/go-spew/spew"
<span class="linenr">11: </span>)
<span class="linenr">12: </span>
<span class="linenr">13: </span>func main() {
<span class="linenr">14: </span>	home, err := os.UserHomeDir()
<span class="linenr">15: </span>	if err != nil {
<span class="linenr">16: </span>		panic(err)
<span class="linenr">17: </span>	}
<span class="linenr">18: </span>
<span class="linenr">19: </span>	file := filepath.Join(home, "src", "github.com", "shanexu", "go-playground", "helloworld", "main.go")
<span class="linenr">20: </span>	src, err := ioutil.ReadFile(file)
<span class="linenr">21: </span>	if err != nil {
<span class="linenr">22: </span>		panic(err)
<span class="linenr">23: </span>	}
<span class="linenr">24: </span>
<span class="linenr">25: </span>	fset := token.NewFileSet()
<span class="linenr">26: </span>	f, err := parser.ParseFile(fset, "main.go", src, parser.AllErrors)
<span class="linenr">27: </span>	if err != nil {
<span class="linenr">28: </span>		panic(err)
<span class="linenr">29: </span>	}
<span class="linenr">30: </span>
<span class="linenr">31: </span>	spew.Dump(f)
<span class="linenr">32: </span>}  
</pre>
</div>

<p>
得到AST：
</p>

<script src="https://gist.github.com/shanexu/93b83f1d2b9a305042b6c0ad96f0c201.js"></script>  

<p>
而 <code>cmd/compile/internal/syntax.Parse</code> 的结果则都是 <code>cmd/compile/internal/syntax</code> 包下的类型。基本都能和 <code>go/ast</code> 下的类型一一对应。比如：ast.File和syntax.File，ast.ExprStmt和syntax.ExprStmt，ast.Ident和syntax.Name，ast.CallExpr和syntax.CallExpr，ast.SelectorExpr和syntax.SelectorExpr。
</p>

<p>
我们现在可以对AST出手。
例如我们想针对所有main包下以hello开头的函数在进入方法时打印“start ${方法名}...”，在离开方法是打印“stop ${方法名}...”， 则可以在文件 <code>cmd/compile/internal/gc/noder.go</code> Parse结束后，修改p.file的值。代码如下：
</p>
<div class="org-src-container">
<pre class="src src-go"><span class="linenr">52: </span>			p.file, _ = syntax.Parse(base, f, p.error, p.pragma, syntax.CheckBranches) // errors are tracked via p.error
<span class="linenr">53: </span>			if p.file.PkgName.Value == "main" {
<span class="linenr">54: </span>				for _, d := range p.file.DeclList {
<span class="linenr">55: </span>					d, _ := d.(*syntax.FuncDecl)
<span class="linenr">56: </span>					if d == nil {
<span class="linenr">57: </span>						continue
<span class="linenr">58: </span>					}
<span class="linenr">59: </span>					if !strings.HasPrefix(d.Name.Value, "hello") {
<span class="linenr">60: </span>						continue
<span class="linenr">61: </span>					}
<span class="linenr">62: </span>					d.Body.List = append([]syntax.Stmt{
<span class="linenr">63: </span>						&amp;syntax.ExprStmt{
<span class="linenr">64: </span>							X: &amp;syntax.CallExpr{
<span class="linenr">65: </span>								Fun: &amp;syntax.SelectorExpr{
<span class="linenr">66: </span>									X:   &amp;syntax.Name{Value: "fmt"},
<span class="linenr">67: </span>									Sel: &amp;syntax.Name{Value: "Println"},
<span class="linenr">68: </span>								},
<span class="linenr">69: </span>								ArgList: []syntax.Expr{
<span class="linenr">70: </span>									&amp;syntax.BasicLit{
<span class="linenr">71: </span>										Value: strconv.Quote("start " + d.Name.Value + "..."),
<span class="linenr">72: </span>										Kind:  syntax.StringLit,
<span class="linenr">73: </span>									},
<span class="linenr">74: </span>								},
<span class="linenr">75: </span>							},
<span class="linenr">76: </span>						},
<span class="linenr">77: </span>						&amp;syntax.CallStmt{
<span class="linenr">78: </span>							Tok: syntax.Defer,
<span class="linenr">79: </span>							Call: &amp;syntax.CallExpr{
<span class="linenr">80: </span>								Fun: &amp;syntax.SelectorExpr{
<span class="linenr">81: </span>									X:   &amp;syntax.Name{Value: "fmt"},
<span class="linenr">82: </span>									Sel: &amp;syntax.Name{Value: "Println"},
<span class="linenr">83: </span>								},
<span class="linenr">84: </span>								ArgList: []syntax.Expr{
<span class="linenr">85: </span>									&amp;syntax.BasicLit{
<span class="linenr">86: </span>										Value: strconv.Quote("stop " + d.Name.Value + "..."),
<span class="linenr">87: </span>										Kind:  syntax.StringLit,
<span class="linenr">88: </span>									},
<span class="linenr">89: </span>								},
<span class="linenr">90: </span>							},
<span class="linenr">91: </span>						},
<span class="linenr">92: </span>					}, d.Body.List...)
<span class="linenr">93: </span>				}
<span class="linenr">94: </span>			}  
</pre>
</div>

<p>
修改完后需要重新编译golang。
</p>

<div class="org-src-container">
<pre class="src src-text">cd $HOME/src/github.com/golang/go/src
./make.bash

cd $HOME/src/github.com/shanexu/go-playground
go clean -cache
go run helloworld/main.go
</pre>
</div>

<p>
看到如下结果：
</p>
<div class="org-src-container">
<pre class="src src-text">start hello...
hello world
stop hello...  
</pre>
</div>

<p>
在修改了AST之后，实际上hello方法的源码应该长这样：
</p>

<div class="org-src-container">
<pre class="src src-go">func hello(ctx context.Context) {
	fmt.Println("start hello...")
	defer fmt.Println("stop hello...")
	fmt.Println("hello world")
}
</pre>
</div>

<p>
这里有个问题，插入的代码新引入了fmt包，如果原始代码里面没有引入fmt包会怎样？
</p>

<div class="org-src-container">
<pre class="src src-text">$ go clean -cache; go run helloworld/main.go
# command-line-arguments
helloworld/main.go:7:16: undefined: fmt in fmt.Println  
</pre>
</div>

<p>
果然编译失败了。
</p>

<p>
在语法树中按需插入import呢？
</p>

<div class="org-src-container">
<pre class="src src-go"><span class="linenr"> 52: </span>			if p.file.PkgName.Value == "main" {
<span class="linenr"> 53: </span>				for _, d := range p.file.DeclList {
<span class="linenr"> 54: </span>					d, _ := d.(*syntax.FuncDecl)
<span class="linenr"> 55: </span>					if d == nil {
<span class="linenr"> 56: </span>						continue
<span class="linenr"> 57: </span>					}
<span class="linenr"> 58: </span>					if !strings.HasPrefix(d.Name.Value, "hello") {
<span class="linenr"> 59: </span>						continue
<span class="linenr"> 60: </span>					}
<span class="linenr"> 61: </span>					hasHello = true
<span class="linenr"> 62: </span>					d.Body.List = append([]syntax.Stmt{
<span class="linenr"> 63: </span>						&amp;syntax.ExprStmt{
<span class="linenr"> 64: </span>							X: &amp;syntax.CallExpr{
<span class="linenr"> 65: </span>								Fun: &amp;syntax.SelectorExpr{
<span class="linenr"> 66: </span>									X:   &amp;syntax.Name{Value: "fmt"},
<span class="linenr"> 67: </span>									Sel: &amp;syntax.Name{Value: "Println"},
<span class="linenr"> 68: </span>								},
<span class="linenr"> 69: </span>								ArgList: []syntax.Expr{
<span class="linenr"> 70: </span>									&amp;syntax.BasicLit{
<span class="linenr"> 71: </span>										Value: strconv.Quote("start " + d.Name.Value + "..."),
<span class="linenr"> 72: </span>										Kind:  syntax.StringLit,
<span class="linenr"> 73: </span>									},
<span class="linenr"> 74: </span>								},
<span class="linenr"> 75: </span>							},
<span class="linenr"> 76: </span>						},
<span class="linenr"> 77: </span>						&amp;syntax.CallStmt{
<span class="linenr"> 78: </span>							Tok: syntax.Defer,
<span class="linenr"> 79: </span>							Call: &amp;syntax.CallExpr{
<span class="linenr"> 80: </span>								Fun: &amp;syntax.SelectorExpr{
<span class="linenr"> 81: </span>									X:   &amp;syntax.Name{Value: "fmt"},
<span class="linenr"> 82: </span>									Sel: &amp;syntax.Name{Value: "Println"},
<span class="linenr"> 83: </span>								},
<span class="linenr"> 84: </span>								ArgList: []syntax.Expr{
<span class="linenr"> 85: </span>									&amp;syntax.BasicLit{
<span class="linenr"> 86: </span>										Value: strconv.Quote("stop " + d.Name.Value + "..."),
<span class="linenr"> 87: </span>										Kind:  syntax.StringLit,
<span class="linenr"> 88: </span>									},
<span class="linenr"> 89: </span>								},
<span class="linenr"> 90: </span>							},
<span class="linenr"> 91: </span>						},
<span class="linenr"> 92: </span>					}, d.Body.List...)
<span class="linenr"> 93: </span>				}
<span class="linenr"> 94: </span>			}
<span class="linenr"> 95: </span>			if hasHello {
<span class="linenr"> 96: </span>				hasFmtImport := false
<span class="linenr"> 97: </span>				for _, d := range p.file.DeclList {
<span class="linenr"> 98: </span>					d, _ := d.(*syntax.ImportDecl)
<span class="linenr"> 99: </span>					if d == nil {
<span class="linenr">100: </span>						continue
<span class="linenr">101: </span>					}
<span class="linenr">102: </span>					if d.Path.Value != "fmt" {
<span class="linenr">103: </span>						continue
<span class="linenr">104: </span>					}
<span class="linenr">105: </span>					hasFmtImport = true
<span class="linenr">106: </span>					break
<span class="linenr">107: </span>				}
<span class="linenr">108: </span>				if !hasFmtImport {
<span class="linenr">109: </span>					p.file.DeclList = append([]syntax.Decl{
<span class="linenr">110: </span>						&amp;syntax.ImportDecl{
<span class="linenr">111: </span>							Path: &amp;syntax.BasicLit{
<span class="linenr">112: </span>								Value: `"fmt"`, Kind: syntax.StringLit,
<span class="linenr">113: </span>							},
<span class="linenr">114: </span>						},
<span class="linenr">115: </span>					}, p.file.DeclList...)
<span class="linenr">116: </span>				}
<span class="linenr">117: </span>			}  
</pre>
</div>

<p>
重新编译golang，执行go run
</p>

<div class="org-src-container">
<pre class="src src-text">$ go clean -cache; go run helloworld/main.go
# command-line-arguments
helloworld/main.go:1:9: can't find import: "fmt"
</pre>
</div>

<p>
根据错误信息找到，抛错位置，发现parseFile过程中，有findpkg的过程，起调用栈如下。
</p>

<div class="org-src-container">
<pre class="src src-dot">digraph G {
"cmd/compile/internal/gc.Main at main.go:512" -&gt; "cmd/compile/internal/gc.parseFiles at noder.go:128" -&gt; "cmd/compile/internal/gc.(*noder).node at noder.go:310" -&gt; "cmd/compile/internal/gc.(*noder).decls at noder.go:355" -&gt; "cmd/compile/internal/gc.(*noder).importDecl at noder.go:379" -&gt; "cmd/compile/internal/gc.importfile at main.go:1120" -&gt; "cmd/compile/internal/gc.findpkg at main.go:989"
}
</pre>
</div>

<p>
包变量 <code>packageFile</code> 这个map中获取相关包的信息。
</p>
<div class="org-src-container">
<pre class="src src-go"><span class="linenr">988: </span>	if packageFile != nil {
<span class="linenr">989: </span>		file, ok = packageFile[name]
<span class="linenr">990: </span>		return file, ok
<span class="linenr">991: </span>	}  
</pre>
</div>

<p>
包变量 <code>packageFile</code> 在 <code>readImportCfg</code> 方法中初始化。
</p>

<div class="org-src-container">
<pre class="src src-dot">digraph G {
"main.main at main.go:51" -&gt; "cmd/compile/internal/gc.Main at main.go:269" -&gt; "cmd/internal/objabi.Flagparse at flag.go:34" -&gt; "flag.Parse at flag.go:996" -&gt; "flag.(*FlagSet).Parse at flag.go:968" -&gt; "flag.(*FlagSet).parseOne at flag.go:949" -&gt; "cmd/internal/objabi.fn1.Set at flag.go:158" -&gt; "cmd/compile/internal/gc.readImportCfg at main.go:806"
}
</pre>
</div>

<p>
所以 <code>readImportCfg</code> 方法的入参就是，调用compile命令时，选项 <code>-importcfg</code> 的值。
</p>

<div class="org-src-container">
<pre class="src src-go"><span class="linenr">805: </span>func readImportCfg(file string) {
<span class="linenr">806: </span>	packageFile = map[string]string{}
<span class="linenr">807: </span>	data, err := ioutil.ReadFile(file)
<span class="linenr">808: </span>	if err != nil {
<span class="linenr">809: </span>		log.Fatalf("-importcfg: %v", err)
<span class="linenr">810: </span>	}
</pre>
</div>

<p>
要解决这个问题，就需要在 <code>importcfg</code> 文件中加入新加的包。
</p>

<p>
问题又回到的了 <code>importcfg</code> 文件的生成过程了。
</p>

<p>
文件 <code>cmd/go/internal/work/exec.go</code> 第634行，有关importcfg的内容的逻辑。
</p>

<div class="org-src-container">
<pre class="src src-go"><span class="linenr">634: </span>	// Prepare Go import config.
<span class="linenr">635: </span>	// We start it off with a comment so it can't be empty, so icfg.Bytes() below is never nil.
<span class="linenr">636: </span>	// It should never be empty anyway, but there have been bugs in the past that resulted
<span class="linenr">637: </span>	// in empty configs, which then unfortunately turn into "no config passed to compiler",
<span class="linenr">638: </span>	// and the compiler falls back to looking in pkg itself, which mostly works,
<span class="linenr">639: </span>	// except when it doesn't.
<span class="linenr">640: </span>	var icfg bytes.Buffer
<span class="linenr">641: </span>	fmt.Fprintf(&amp;icfg, "# import config\n")
<span class="linenr">642: </span>	for i, raw := range a.Package.Internal.RawImports {
<span class="linenr">643: </span>		final := a.Package.Imports[i]
<span class="linenr">644: </span>		if final != raw {
<span class="linenr">645: </span>			fmt.Fprintf(&amp;icfg, "importmap %s=%s\n", raw, final)
<span class="linenr">646: </span>		}
<span class="linenr">647: </span>	}  
</pre>
</div>

<p>
现在归结于 <code>Package.Imports</code> 的值的设置了。
</p>

<p>
文件 <code>go/build/build.go=，先用 =go/parser.ParseFile</code> 解析源文件，然后获取其中的imports。
</p>
<div class="org-src-container">
<pre class="src src-go"><span class="linenr">847: </span>		pf, err := parser.ParseFile(fset, filename, data, parser.ImportsOnly|parser.ParseComments)
<span class="linenr">848: </span>		if err != nil {
<span class="linenr">849: </span>			badFile(err)
<span class="linenr">850: </span>			continue
<span class="linenr">851: </span>		}
</pre>
</div>

<p>
修改代码如下：
</p>

<div class="org-src-container">
<pre class="src src-go"><span class="linenr">847: </span>		pf, err := parser.ParseFile(fset, filename, data, parser.ImportsOnly|parser.ParseComments)
<span class="linenr">848: </span>		if err != nil {
<span class="linenr">849: </span>			badFile(err)
<span class="linenr">850: </span>			continue
<span class="linenr">851: </span>		}
<span class="linenr">852: </span>
<span class="linenr">853: </span>		if strings.HasSuffix(filename, "helloworld/main.go") {
<span class="linenr">854: </span>			hasFmtImport := false
<span class="linenr">855: </span>			for _, i := range pf.Imports {
<span class="linenr">856: </span>				if i.Path.Value == `"fmt"` {
<span class="linenr">857: </span>					hasFmtImport = true
<span class="linenr">858: </span>					break
<span class="linenr">859: </span>				}
<span class="linenr">860: </span>			}
<span class="linenr">861: </span>			if !hasFmtImport {
<span class="linenr">862: </span>				pf.Imports = append(pf.Imports, &amp;ast.ImportSpec{
<span class="linenr">863: </span>					Path: &amp;ast.BasicLit{
<span class="linenr">864: </span>						Value: `"fmt"`,
<span class="linenr">865: </span>						Kind:  token.STRING,
<span class="linenr">866: </span>					},
<span class="linenr">867: </span>				})
<span class="linenr">868: </span>				if len(pf.Decls) &gt; 0 {
<span class="linenr">869: </span>					d, ok := pf.Decls[0].(*ast.GenDecl)
<span class="linenr">870: </span>					if ok {
<span class="linenr">871: </span>						d.Specs = append(d.Specs, &amp;ast.ImportSpec{
<span class="linenr">872: </span>							Path: &amp;ast.BasicLit{
<span class="linenr">873: </span>								Kind:  token.STRING,
<span class="linenr">874: </span>								Value: `"fmt"`,
<span class="linenr">875: </span>							},
<span class="linenr">876: </span>						})
<span class="linenr">877: </span>					}
<span class="linenr">878: </span>				}
<span class="linenr">879: </span>			}
<span class="linenr">880: </span>		}  
</pre>
</div>

<p>
重新编译golang，执行go run
</p>

<div class="org-src-container">
<pre class="src src-text">$ go clean -cache; go run helloworld/main.go
start hello...
stop hello...  
</pre>
</div>

<p>
成功加上了import。
</p>
</div>
</div>

<div id="outline-container-orgc04d234" class="outline-2">
<h2 id="orgc04d234">创业未半</h2>
<div class="outline-text-2" id="text-orgc04d234">
<p>
至此对golang编译器的解析和hack的过程也结束了。可见通过修改编译器生成的AST的方式，我们可以给特定文件、特定包、特定方法加上自定义代码。这里给golang实现aop提供了一种另类的思路。诚然要完成像 <code>AspectJ</code> 这样完整的解决方案，还有很大一段路路要走。
</p>
</div>
</div>

</div>
</div>
    <div>
      <div class="post-meta">
        <span title="post date" class="post-info">2019-10-09</span>
        <span title="last modification date" class="post-info">2021-02-14</span>
        <span title="tags" class="post-info"><a href="/tags/golang/">golang</a></span>
        <span title="author" class="post-info">shanexu</span>
      </div>
      <section>
        <h1>Comments</h1>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
          //var disqus_developer = 1;
          var disqus_identifier = "/blog/2019/10/09/golang-aop";
          var disqus_url = "https://xusheng.org/blog/2019/10/09/golang-aop";
          var disqus_shortname = 'shanexu';
          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="//disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
       <div id="hashover"></div>
       <script type="text/javascript" src="/hashover.php"></script>
       <noscript>You must have JavaScript enabled to use the comments.</noscript>
      </section>
      <script src="//code.jquery.com/jquery-latest.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.js"></script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="/media/js/main.js"></script>
      <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-74684473-1']);
        _gaq.push(['_trackPageview']);
        (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
      </script>
      <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 29.x (<a href="http://orgmode.org">Org mode</a> 9.x)</p>
        <p>
          Copyright &copy; 2012 - <span id="footerYear"></span> <a href="mailto:xusheng0711 &lt;at&gt; gmail &lt;dot&gt; com">shanexu</a>
          &nbsp;&nbsp;-&nbsp;&nbsp;
          Powered by <a href="https://github.com/kelvinh/org-page" target="_blank">org-page</a>
          <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
        </p>
      </div>
    </div>

  </body>
</html>
