#+TITLE:       direnv
#+AUTHOR:      Shane Xu
#+EMAIL:       xusheng0711@gmail.com
#+DATE:        2016-08-14 Sun
#+URI:         /blog/%y/%m/%d/direnv
#+KEYWORDS:    direnv
#+TAGS:        go
#+LANGUAGE:    en
#+OPTIONS:     H:3 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: direnv

2014年的苹果WWDC上有个口号:

#+begin_quote
Write the Code. Change the World.
#+end_quote

然而我觉得 [[http://direnv.net/][direnv]] 的作者则是:

#+begin_quote
Write the Code. Save the World.
#+end_quote

这几年杂七杂八的东西学的太多了，几乎每一门语言都有自身版本和三方库版本的问题，比如java里面有
maven这样的构建工具，来控制三方库的版本。更有甚者，如ruby的rvm，node的nvm，Python的virtualenv，
go的gvm，groovy的GVM，haskell的stack，haskell的cabal。这些工具基本都肩负着三个使命，一是控制
语言的版本，二是控制三方库的set，三是设置环境变量。于是每次到某个工程下面，就要执行 =rvm use xxx= ， 
=nvm use xxx= ，这些命令来切换环境。然后偶尔一次忘记，就会各种神奇的错误。

然而这几天，正好在测试同一个项目，用不同版本的语言编译的效果，结果在不同的环境切换下，竟然
切晕了。虽然用 =tmux= 的分屏，多窗口等方法，勉强能凑活，但是还是偶尔几次忘记自己当前的环境。
所以我想有没有能够，在不同目录下自动切换环境变量的工具。于是用google搜索"directory environment"，
还真被我找到了。

* 安装

#+begin_src bash
git clone https://github.com/direnv/direnv
cd direnv
make install
#+end_src

如果是以下系统的话，还可以用这些系统的包管理工具来安装，着实方便啊。
#+begin_quote
There's package definitions on Homebrew, Arch's AUR, Gentoo go-overlay overlay and NixOS's nixpkgs.
#+end_quote

* 设置

** ZSH
在 =~/.zshrc= 中添加:
#+begin_src bash
eval "$(direnv hook zsh)"
#+end_src

** BASH
在 =~/.bashrc= 中添加:
#+begin_src bash
eval "$(direnv hook bash)"
#+end_src

** FISH
在 =~/.config/fish/config.fish= 中添加:
#+begin_src bash
eval (direnv hook fish)
#+end_src

** TCSH
在 =~/.cshrc= 中添加:
#+begin_src bash
eval `direnv hook tcsh`
#+end_src


* 使用
说到用法的话，差不多只要拿出首页的例子就可以了。
#+begin_src bash
$ cd ~/my_project
$ echo ${FOO-nope}
nope
$ echo export FOO=foo > .envrc
.envrc is not allowed
$ direnv allow .
direnv: reloading
direnv: loading .envrc
direnv export: +FOO
$ echo ${FOO-nope}
foo
$ cd ..
direnv: unloading
direnv export: ~PATH
$ echo ${FOO-nope}
nope
#+end_src

在想要自动切换环境的目录下面新建一个 =.envrc= 文件，文件的内容就是设置环境的命令。
但是要主要的是 =.envrc= 只支持bash语法，因为这个文件最终也是在bash中执行，然后再
设置到对应的shell中的。另外值得一提的是 =~/.direnvrc= 中可以写入全局配置，比如加
一些函数进去。direnv还提供了一个stdlib，通过 =direnv stdlib= 可以查看。

* 实战
比如我现在有个工程要用Python环境，于是只要在工程的根目录下面新建 =.envrc= 文件并
写入如下内容:

#+begin_src bash
layout python
#+end_src

然后在首次进入这个目录的时候，就会在 =.direnv= 这个目录下建立，整套Python的virtualenv。
然而PyCharm似乎不是很满意。PyCharm能够自动识别工程根目录下得 =venv= 目录。但是现在用direnv之后
virtualenv的目录改变了。解决方案有很多。比如不用direnv的layout python，用virtualenv生成的
active脚本，在 =.envrc= 中添加内容：

#+begin_src bash
source venv/bin/active
#+end_src

或者修改 =direnv stdlib= 中的 =python_layout= 方法：

#+begin_src bash
layout_python() {
  local python=${1:-python}
  local old_env=$PWD/virtualenv
  unset PYTHONHOME
  if [[ -d $old_env && $python = python ]]; then
    export VIRTUAL_ENV=$old_env
  else
    local python_version
    python_version=$("$python" -c "import platform as p;print(p.python_version())")
    if [[ -z $python_version ]]; then
      log_error "Could not find python's version"
      return 1
    fi

    export VIRTUAL_ENV=$PWD/venv
    if [[ ! -d $VIRTUAL_ENV ]]; then
      virtualenv "--python=$python" "$VIRTUAL_ENV"
    fi
  fi
  PATH_add "$VIRTUAL_ENV/bin"
}
#+end_src

